# Бекенд

<div align="center"><h2> CodeRun </h2></div>

>Уровень: <font color="red">**сложная**</font>

162. Любимые числа

___

Задача
--------

У Саши есть три любимых числа: 5,6,10.

Кроме них, у Саши есть число N, не содержащее нулей. Он хочет сделать так, чтобы оно делилось хотя бы на одно из его любимых чисел. Для этого он
K раз выполняет следующее: случайно выбирает две цифры, стоящие на разных позициях, и меняет их местами.
Помогите Саше найти вероятность того, что итоговое число будет делиться хотя бы на одно из любимых чисел.

### Формат ввода
В первой строке входных данных подается одно целое число (10≤n≤10^18), не содержащее нулей.

Во второй строке содержится единственное целое число(0≤K≤100)(0≤K≤100) — количество операций над числом N.

### Формат вывода
В единственной строке выведите искомую вероятность. Абсолютная или относительная погрешность не должна превышать 10^(−9).

### Ограничения

<table border="3">
<tr>
<td>

Ограничение времени

</td><td>

1 с

</td></tr>
<td>

Ограничение памяти

</td><td>

256 МБ

</td></tr>
</table>

Пример 1
<table border="3">
<tr>
<td>

Ввод

</td><td>

21

1

</td></tr>
<td>

Вывод

</td><td>

1.000000000000000

</td></tr>
</table>

Пример 2
<table border="3">
<tr>
<td>

Ввод

</td><td>

145

2

</td></tr>
<td>

Вывод

</td><td>

0.333333333333333

</td></tr>
</table>

>Можно было объяснить проще (-_-;)・・・
>
>Как видим пример №1, выше, 21 мы можем переставлять 1 раз, то есть 21 = 12.
>
>А теперь мы должы посмтреть на его цифры (5,6,10) есть ли среди них что может разделить без остатка. 
>В том то и дело что есть, например цифра 6. Поэтому вывод: 1.
>
>А вот пример №2, выше, 145 мы можем переставлять 2 раза, то есть 145 = 451, 514, 145.
>
>Поэтому вывод: 0.3. 

___
Решение:
--------

~~~Java
    public static HashSet<String> perebor(String n, int k){
        HashSet<String> list = new HashSet<String>();
        char[] c = n.toCharArray();
        for (int i = 0; i < c.length; i++){
            for (int j = i; j < c.length; j++) {
                if (i != j){
                    char newC = c[i];
                    c[i] = c[j];
                    c[j] = newC;
                    String s = new String(c);
                    list.add(s);
                    newC = c[j];
                    c[j] = c[i];
                    c[i] = newC;
                }
            }
        }
        k--;
        if (k>0){
            HashSet<String> list_2 = new HashSet<String>();
            for (String s : list){
                list_2.addAll(perebor(s, k));
            }
            return list_2;
        }
        return list;
    }
~~~

Не проходит по времени (￢_￢)


Итог: 
--------

>- [ ] Есть готовое решение 
>- [X] Свой код написан 
